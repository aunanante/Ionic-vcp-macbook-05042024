{"ast":null,"code":"import PostgrestTransformBuilder from './PostgrestTransformBuilder';\nexport default class PostgrestFilterBuilder extends PostgrestTransformBuilder {\n  /**\r\n   * Match only rows where `column` is equal to `value`.\r\n   *\r\n   * To check if the value of `column` is NULL, you should use `.is()` instead.\r\n   *\r\n   * @param column - The column to filter on\r\n   * @param value - The value to filter with\r\n   */\n  eq(column, value) {\n    this.url.searchParams.append(column, `eq.${value}`);\n    return this;\n  }\n  /**\r\n   * Match only rows where `column` is not equal to `value`.\r\n   *\r\n   * @param column - The column to filter on\r\n   * @param value - The value to filter with\r\n   */\n  neq(column, value) {\n    this.url.searchParams.append(column, `neq.${value}`);\n    return this;\n  }\n  /**\r\n   * Match only rows where `column` is greater than `value`.\r\n   *\r\n   * @param column - The column to filter on\r\n   * @param value - The value to filter with\r\n   */\n  gt(column, value) {\n    this.url.searchParams.append(column, `gt.${value}`);\n    return this;\n  }\n  /**\r\n   * Match only rows where `column` is greater than or equal to `value`.\r\n   *\r\n   * @param column - The column to filter on\r\n   * @param value - The value to filter with\r\n   */\n  gte(column, value) {\n    this.url.searchParams.append(column, `gte.${value}`);\n    return this;\n  }\n  /**\r\n   * Match only rows where `column` is less than `value`.\r\n   *\r\n   * @param column - The column to filter on\r\n   * @param value - The value to filter with\r\n   */\n  lt(column, value) {\n    this.url.searchParams.append(column, `lt.${value}`);\n    return this;\n  }\n  /**\r\n   * Match only rows where `column` is less than or equal to `value`.\r\n   *\r\n   * @param column - The column to filter on\r\n   * @param value - The value to filter with\r\n   */\n  lte(column, value) {\n    this.url.searchParams.append(column, `lte.${value}`);\n    return this;\n  }\n  /**\r\n   * Match only rows where `column` matches `pattern` case-sensitively.\r\n   *\r\n   * @param column - The column to filter on\r\n   * @param pattern - The pattern to match with\r\n   */\n  like(column, pattern) {\n    this.url.searchParams.append(column, `like.${pattern}`);\n    return this;\n  }\n  /**\r\n   * Match only rows where `column` matches all of `patterns` case-sensitively.\r\n   *\r\n   * @param column - The column to filter on\r\n   * @param patterns - The patterns to match with\r\n   */\n  likeAllOf(column, patterns) {\n    this.url.searchParams.append(column, `like(all).{${patterns.join(',')}}`);\n    return this;\n  }\n  /**\r\n   * Match only rows where `column` matches any of `patterns` case-sensitively.\r\n   *\r\n   * @param column - The column to filter on\r\n   * @param patterns - The patterns to match with\r\n   */\n  likeAnyOf(column, patterns) {\n    this.url.searchParams.append(column, `like(any).{${patterns.join(',')}}`);\n    return this;\n  }\n  /**\r\n   * Match only rows where `column` matches `pattern` case-insensitively.\r\n   *\r\n   * @param column - The column to filter on\r\n   * @param pattern - The pattern to match with\r\n   */\n  ilike(column, pattern) {\n    this.url.searchParams.append(column, `ilike.${pattern}`);\n    return this;\n  }\n  /**\r\n   * Match only rows where `column` matches all of `patterns` case-insensitively.\r\n   *\r\n   * @param column - The column to filter on\r\n   * @param patterns - The patterns to match with\r\n   */\n  ilikeAllOf(column, patterns) {\n    this.url.searchParams.append(column, `ilike(all).{${patterns.join(',')}}`);\n    return this;\n  }\n  /**\r\n   * Match only rows where `column` matches any of `patterns` case-insensitively.\r\n   *\r\n   * @param column - The column to filter on\r\n   * @param patterns - The patterns to match with\r\n   */\n  ilikeAnyOf(column, patterns) {\n    this.url.searchParams.append(column, `ilike(any).{${patterns.join(',')}}`);\n    return this;\n  }\n  /**\r\n   * Match only rows where `column` IS `value`.\r\n   *\r\n   * For non-boolean columns, this is only relevant for checking if the value of\r\n   * `column` is NULL by setting `value` to `null`.\r\n   *\r\n   * For boolean columns, you can also set `value` to `true` or `false` and it\r\n   * will behave the same way as `.eq()`.\r\n   *\r\n   * @param column - The column to filter on\r\n   * @param value - The value to filter with\r\n   */\n  is(column, value) {\n    this.url.searchParams.append(column, `is.${value}`);\n    return this;\n  }\n  /**\r\n   * Match only rows where `column` is included in the `values` array.\r\n   *\r\n   * @param column - The column to filter on\r\n   * @param values - The values array to filter with\r\n   */\n  in(column, values) {\n    const cleanedValues = values.map(s => {\n      // handle postgrest reserved characters\n      // https://postgrest.org/en/v7.0.0/api.html#reserved-characters\n      if (typeof s === 'string' && new RegExp('[,()]').test(s)) return `\"${s}\"`;else return `${s}`;\n    }).join(',');\n    this.url.searchParams.append(column, `in.(${cleanedValues})`);\n    return this;\n  }\n  /**\r\n   * Only relevant for jsonb, array, and range columns. Match only rows where\r\n   * `column` contains every element appearing in `value`.\r\n   *\r\n   * @param column - The jsonb, array, or range column to filter on\r\n   * @param value - The jsonb, array, or range value to filter with\r\n   */\n  contains(column, value) {\n    if (typeof value === 'string') {\n      // range types can be inclusive '[', ']' or exclusive '(', ')' so just\n      // keep it simple and accept a string\n      this.url.searchParams.append(column, `cs.${value}`);\n    } else if (Array.isArray(value)) {\n      // array\n      this.url.searchParams.append(column, `cs.{${value.join(',')}}`);\n    } else {\n      // json\n      this.url.searchParams.append(column, `cs.${JSON.stringify(value)}`);\n    }\n    return this;\n  }\n  /**\r\n   * Only relevant for jsonb, array, and range columns. Match only rows where\r\n   * every element appearing in `column` is contained by `value`.\r\n   *\r\n   * @param column - The jsonb, array, or range column to filter on\r\n   * @param value - The jsonb, array, or range value to filter with\r\n   */\n  containedBy(column, value) {\n    if (typeof value === 'string') {\n      // range\n      this.url.searchParams.append(column, `cd.${value}`);\n    } else if (Array.isArray(value)) {\n      // array\n      this.url.searchParams.append(column, `cd.{${value.join(',')}}`);\n    } else {\n      // json\n      this.url.searchParams.append(column, `cd.${JSON.stringify(value)}`);\n    }\n    return this;\n  }\n  /**\r\n   * Only relevant for range columns. Match only rows where every element in\r\n   * `column` is greater than any element in `range`.\r\n   *\r\n   * @param column - The range column to filter on\r\n   * @param range - The range to filter with\r\n   */\n  rangeGt(column, range) {\n    this.url.searchParams.append(column, `sr.${range}`);\n    return this;\n  }\n  /**\r\n   * Only relevant for range columns. Match only rows where every element in\r\n   * `column` is either contained in `range` or greater than any element in\r\n   * `range`.\r\n   *\r\n   * @param column - The range column to filter on\r\n   * @param range - The range to filter with\r\n   */\n  rangeGte(column, range) {\n    this.url.searchParams.append(column, `nxl.${range}`);\n    return this;\n  }\n  /**\r\n   * Only relevant for range columns. Match only rows where every element in\r\n   * `column` is less than any element in `range`.\r\n   *\r\n   * @param column - The range column to filter on\r\n   * @param range - The range to filter with\r\n   */\n  rangeLt(column, range) {\n    this.url.searchParams.append(column, `sl.${range}`);\n    return this;\n  }\n  /**\r\n   * Only relevant for range columns. Match only rows where every element in\r\n   * `column` is either contained in `range` or less than any element in\r\n   * `range`.\r\n   *\r\n   * @param column - The range column to filter on\r\n   * @param range - The range to filter with\r\n   */\n  rangeLte(column, range) {\n    this.url.searchParams.append(column, `nxr.${range}`);\n    return this;\n  }\n  /**\r\n   * Only relevant for range columns. Match only rows where `column` is\r\n   * mutually exclusive to `range` and there can be no element between the two\r\n   * ranges.\r\n   *\r\n   * @param column - The range column to filter on\r\n   * @param range - The range to filter with\r\n   */\n  rangeAdjacent(column, range) {\n    this.url.searchParams.append(column, `adj.${range}`);\n    return this;\n  }\n  /**\r\n   * Only relevant for array and range columns. Match only rows where\r\n   * `column` and `value` have an element in common.\r\n   *\r\n   * @param column - The array or range column to filter on\r\n   * @param value - The array or range value to filter with\r\n   */\n  overlaps(column, value) {\n    if (typeof value === 'string') {\n      // range\n      this.url.searchParams.append(column, `ov.${value}`);\n    } else {\n      // array\n      this.url.searchParams.append(column, `ov.{${value.join(',')}}`);\n    }\n    return this;\n  }\n  /**\r\n   * Only relevant for text and tsvector columns. Match only rows where\r\n   * `column` matches the query string in `query`.\r\n   *\r\n   * @param column - The text or tsvector column to filter on\r\n   * @param query - The query text to match with\r\n   * @param options - Named parameters\r\n   * @param options.config - The text search configuration to use\r\n   * @param options.type - Change how the `query` text is interpreted\r\n   */\n  textSearch(column, query, {\n    config,\n    type\n  } = {}) {\n    let typePart = '';\n    if (type === 'plain') {\n      typePart = 'pl';\n    } else if (type === 'phrase') {\n      typePart = 'ph';\n    } else if (type === 'websearch') {\n      typePart = 'w';\n    }\n    const configPart = config === undefined ? '' : `(${config})`;\n    this.url.searchParams.append(column, `${typePart}fts${configPart}.${query}`);\n    return this;\n  }\n  /**\r\n   * Match only rows where each column in `query` keys is equal to its\r\n   * associated value. Shorthand for multiple `.eq()`s.\r\n   *\r\n   * @param query - The object to filter with, with column names as keys mapped\r\n   * to their filter values\r\n   */\n  match(query) {\n    Object.entries(query).forEach(([column, value]) => {\n      this.url.searchParams.append(column, `eq.${value}`);\n    });\n    return this;\n  }\n  /**\r\n   * Match only rows which doesn't satisfy the filter.\r\n   *\r\n   * Unlike most filters, `opearator` and `value` are used as-is and need to\r\n   * follow [PostgREST\r\n   * syntax](https://postgrest.org/en/stable/api.html#operators). You also need\r\n   * to make sure they are properly sanitized.\r\n   *\r\n   * @param column - The column to filter on\r\n   * @param operator - The operator to be negated to filter with, following\r\n   * PostgREST syntax\r\n   * @param value - The value to filter with, following PostgREST syntax\r\n   */\n  not(column, operator, value) {\n    this.url.searchParams.append(column, `not.${operator}.${value}`);\n    return this;\n  }\n  /**\r\n   * Match only rows which satisfy at least one of the filters.\r\n   *\r\n   * Unlike most filters, `filters` is used as-is and needs to follow [PostgREST\r\n   * syntax](https://postgrest.org/en/stable/api.html#operators). You also need\r\n   * to make sure it's properly sanitized.\r\n   *\r\n   * It's currently not possible to do an `.or()` filter across multiple tables.\r\n   *\r\n   * @param filters - The filters to use, following PostgREST syntax\r\n   * @param options - Named parameters\r\n   * @param options.referencedTable - Set this to filter on referenced tables\r\n   * instead of the parent table\r\n   * @param options.foreignTable - Deprecated, use `referencedTable` instead\r\n   */\n  or(filters, {\n    foreignTable,\n    referencedTable = foreignTable\n  } = {}) {\n    const key = referencedTable ? `${referencedTable}.or` : 'or';\n    this.url.searchParams.append(key, `(${filters})`);\n    return this;\n  }\n  /**\r\n   * Match only rows which satisfy the filter. This is an escape hatch - you\r\n   * should use the specific filter methods wherever possible.\r\n   *\r\n   * Unlike most filters, `opearator` and `value` are used as-is and need to\r\n   * follow [PostgREST\r\n   * syntax](https://postgrest.org/en/stable/api.html#operators). You also need\r\n   * to make sure they are properly sanitized.\r\n   *\r\n   * @param column - The column to filter on\r\n   * @param operator - The operator to filter with, following PostgREST syntax\r\n   * @param value - The value to filter with, following PostgREST syntax\r\n   */\n  filter(column, operator, value) {\n    this.url.searchParams.append(column, `${operator}.${value}`);\n    return this;\n  }\n}","map":{"version":3,"names":["PostgrestTransformBuilder","PostgrestFilterBuilder","eq","column","value","url","searchParams","append","neq","gt","gte","lt","lte","like","pattern","likeAllOf","patterns","join","likeAnyOf","ilike","ilikeAllOf","ilikeAnyOf","is","in","values","cleanedValues","map","s","RegExp","test","contains","Array","isArray","JSON","stringify","containedBy","rangeGt","range","rangeGte","rangeLt","rangeLte","rangeAdjacent","overlaps","textSearch","query","config","type","typePart","configPart","undefined","match","Object","entries","forEach","not","operator","or","filters","foreignTable","referencedTable","key","filter"],"sources":["C:/Users/jclon/chatgptVcp/Ionic-vcp-macbook27mars22024/node_modules/@supabase/postgrest-js/dist/module/PostgrestFilterBuilder.js"],"sourcesContent":["import PostgrestTransformBuilder from './PostgrestTransformBuilder';\r\nexport default class PostgrestFilterBuilder extends PostgrestTransformBuilder {\r\n    /**\r\n     * Match only rows where `column` is equal to `value`.\r\n     *\r\n     * To check if the value of `column` is NULL, you should use `.is()` instead.\r\n     *\r\n     * @param column - The column to filter on\r\n     * @param value - The value to filter with\r\n     */\r\n    eq(column, value) {\r\n        this.url.searchParams.append(column, `eq.${value}`);\r\n        return this;\r\n    }\r\n    /**\r\n     * Match only rows where `column` is not equal to `value`.\r\n     *\r\n     * @param column - The column to filter on\r\n     * @param value - The value to filter with\r\n     */\r\n    neq(column, value) {\r\n        this.url.searchParams.append(column, `neq.${value}`);\r\n        return this;\r\n    }\r\n    /**\r\n     * Match only rows where `column` is greater than `value`.\r\n     *\r\n     * @param column - The column to filter on\r\n     * @param value - The value to filter with\r\n     */\r\n    gt(column, value) {\r\n        this.url.searchParams.append(column, `gt.${value}`);\r\n        return this;\r\n    }\r\n    /**\r\n     * Match only rows where `column` is greater than or equal to `value`.\r\n     *\r\n     * @param column - The column to filter on\r\n     * @param value - The value to filter with\r\n     */\r\n    gte(column, value) {\r\n        this.url.searchParams.append(column, `gte.${value}`);\r\n        return this;\r\n    }\r\n    /**\r\n     * Match only rows where `column` is less than `value`.\r\n     *\r\n     * @param column - The column to filter on\r\n     * @param value - The value to filter with\r\n     */\r\n    lt(column, value) {\r\n        this.url.searchParams.append(column, `lt.${value}`);\r\n        return this;\r\n    }\r\n    /**\r\n     * Match only rows where `column` is less than or equal to `value`.\r\n     *\r\n     * @param column - The column to filter on\r\n     * @param value - The value to filter with\r\n     */\r\n    lte(column, value) {\r\n        this.url.searchParams.append(column, `lte.${value}`);\r\n        return this;\r\n    }\r\n    /**\r\n     * Match only rows where `column` matches `pattern` case-sensitively.\r\n     *\r\n     * @param column - The column to filter on\r\n     * @param pattern - The pattern to match with\r\n     */\r\n    like(column, pattern) {\r\n        this.url.searchParams.append(column, `like.${pattern}`);\r\n        return this;\r\n    }\r\n    /**\r\n     * Match only rows where `column` matches all of `patterns` case-sensitively.\r\n     *\r\n     * @param column - The column to filter on\r\n     * @param patterns - The patterns to match with\r\n     */\r\n    likeAllOf(column, patterns) {\r\n        this.url.searchParams.append(column, `like(all).{${patterns.join(',')}}`);\r\n        return this;\r\n    }\r\n    /**\r\n     * Match only rows where `column` matches any of `patterns` case-sensitively.\r\n     *\r\n     * @param column - The column to filter on\r\n     * @param patterns - The patterns to match with\r\n     */\r\n    likeAnyOf(column, patterns) {\r\n        this.url.searchParams.append(column, `like(any).{${patterns.join(',')}}`);\r\n        return this;\r\n    }\r\n    /**\r\n     * Match only rows where `column` matches `pattern` case-insensitively.\r\n     *\r\n     * @param column - The column to filter on\r\n     * @param pattern - The pattern to match with\r\n     */\r\n    ilike(column, pattern) {\r\n        this.url.searchParams.append(column, `ilike.${pattern}`);\r\n        return this;\r\n    }\r\n    /**\r\n     * Match only rows where `column` matches all of `patterns` case-insensitively.\r\n     *\r\n     * @param column - The column to filter on\r\n     * @param patterns - The patterns to match with\r\n     */\r\n    ilikeAllOf(column, patterns) {\r\n        this.url.searchParams.append(column, `ilike(all).{${patterns.join(',')}}`);\r\n        return this;\r\n    }\r\n    /**\r\n     * Match only rows where `column` matches any of `patterns` case-insensitively.\r\n     *\r\n     * @param column - The column to filter on\r\n     * @param patterns - The patterns to match with\r\n     */\r\n    ilikeAnyOf(column, patterns) {\r\n        this.url.searchParams.append(column, `ilike(any).{${patterns.join(',')}}`);\r\n        return this;\r\n    }\r\n    /**\r\n     * Match only rows where `column` IS `value`.\r\n     *\r\n     * For non-boolean columns, this is only relevant for checking if the value of\r\n     * `column` is NULL by setting `value` to `null`.\r\n     *\r\n     * For boolean columns, you can also set `value` to `true` or `false` and it\r\n     * will behave the same way as `.eq()`.\r\n     *\r\n     * @param column - The column to filter on\r\n     * @param value - The value to filter with\r\n     */\r\n    is(column, value) {\r\n        this.url.searchParams.append(column, `is.${value}`);\r\n        return this;\r\n    }\r\n    /**\r\n     * Match only rows where `column` is included in the `values` array.\r\n     *\r\n     * @param column - The column to filter on\r\n     * @param values - The values array to filter with\r\n     */\r\n    in(column, values) {\r\n        const cleanedValues = values\r\n            .map((s) => {\r\n            // handle postgrest reserved characters\r\n            // https://postgrest.org/en/v7.0.0/api.html#reserved-characters\r\n            if (typeof s === 'string' && new RegExp('[,()]').test(s))\r\n                return `\"${s}\"`;\r\n            else\r\n                return `${s}`;\r\n        })\r\n            .join(',');\r\n        this.url.searchParams.append(column, `in.(${cleanedValues})`);\r\n        return this;\r\n    }\r\n    /**\r\n     * Only relevant for jsonb, array, and range columns. Match only rows where\r\n     * `column` contains every element appearing in `value`.\r\n     *\r\n     * @param column - The jsonb, array, or range column to filter on\r\n     * @param value - The jsonb, array, or range value to filter with\r\n     */\r\n    contains(column, value) {\r\n        if (typeof value === 'string') {\r\n            // range types can be inclusive '[', ']' or exclusive '(', ')' so just\r\n            // keep it simple and accept a string\r\n            this.url.searchParams.append(column, `cs.${value}`);\r\n        }\r\n        else if (Array.isArray(value)) {\r\n            // array\r\n            this.url.searchParams.append(column, `cs.{${value.join(',')}}`);\r\n        }\r\n        else {\r\n            // json\r\n            this.url.searchParams.append(column, `cs.${JSON.stringify(value)}`);\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Only relevant for jsonb, array, and range columns. Match only rows where\r\n     * every element appearing in `column` is contained by `value`.\r\n     *\r\n     * @param column - The jsonb, array, or range column to filter on\r\n     * @param value - The jsonb, array, or range value to filter with\r\n     */\r\n    containedBy(column, value) {\r\n        if (typeof value === 'string') {\r\n            // range\r\n            this.url.searchParams.append(column, `cd.${value}`);\r\n        }\r\n        else if (Array.isArray(value)) {\r\n            // array\r\n            this.url.searchParams.append(column, `cd.{${value.join(',')}}`);\r\n        }\r\n        else {\r\n            // json\r\n            this.url.searchParams.append(column, `cd.${JSON.stringify(value)}`);\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Only relevant for range columns. Match only rows where every element in\r\n     * `column` is greater than any element in `range`.\r\n     *\r\n     * @param column - The range column to filter on\r\n     * @param range - The range to filter with\r\n     */\r\n    rangeGt(column, range) {\r\n        this.url.searchParams.append(column, `sr.${range}`);\r\n        return this;\r\n    }\r\n    /**\r\n     * Only relevant for range columns. Match only rows where every element in\r\n     * `column` is either contained in `range` or greater than any element in\r\n     * `range`.\r\n     *\r\n     * @param column - The range column to filter on\r\n     * @param range - The range to filter with\r\n     */\r\n    rangeGte(column, range) {\r\n        this.url.searchParams.append(column, `nxl.${range}`);\r\n        return this;\r\n    }\r\n    /**\r\n     * Only relevant for range columns. Match only rows where every element in\r\n     * `column` is less than any element in `range`.\r\n     *\r\n     * @param column - The range column to filter on\r\n     * @param range - The range to filter with\r\n     */\r\n    rangeLt(column, range) {\r\n        this.url.searchParams.append(column, `sl.${range}`);\r\n        return this;\r\n    }\r\n    /**\r\n     * Only relevant for range columns. Match only rows where every element in\r\n     * `column` is either contained in `range` or less than any element in\r\n     * `range`.\r\n     *\r\n     * @param column - The range column to filter on\r\n     * @param range - The range to filter with\r\n     */\r\n    rangeLte(column, range) {\r\n        this.url.searchParams.append(column, `nxr.${range}`);\r\n        return this;\r\n    }\r\n    /**\r\n     * Only relevant for range columns. Match only rows where `column` is\r\n     * mutually exclusive to `range` and there can be no element between the two\r\n     * ranges.\r\n     *\r\n     * @param column - The range column to filter on\r\n     * @param range - The range to filter with\r\n     */\r\n    rangeAdjacent(column, range) {\r\n        this.url.searchParams.append(column, `adj.${range}`);\r\n        return this;\r\n    }\r\n    /**\r\n     * Only relevant for array and range columns. Match only rows where\r\n     * `column` and `value` have an element in common.\r\n     *\r\n     * @param column - The array or range column to filter on\r\n     * @param value - The array or range value to filter with\r\n     */\r\n    overlaps(column, value) {\r\n        if (typeof value === 'string') {\r\n            // range\r\n            this.url.searchParams.append(column, `ov.${value}`);\r\n        }\r\n        else {\r\n            // array\r\n            this.url.searchParams.append(column, `ov.{${value.join(',')}}`);\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Only relevant for text and tsvector columns. Match only rows where\r\n     * `column` matches the query string in `query`.\r\n     *\r\n     * @param column - The text or tsvector column to filter on\r\n     * @param query - The query text to match with\r\n     * @param options - Named parameters\r\n     * @param options.config - The text search configuration to use\r\n     * @param options.type - Change how the `query` text is interpreted\r\n     */\r\n    textSearch(column, query, { config, type } = {}) {\r\n        let typePart = '';\r\n        if (type === 'plain') {\r\n            typePart = 'pl';\r\n        }\r\n        else if (type === 'phrase') {\r\n            typePart = 'ph';\r\n        }\r\n        else if (type === 'websearch') {\r\n            typePart = 'w';\r\n        }\r\n        const configPart = config === undefined ? '' : `(${config})`;\r\n        this.url.searchParams.append(column, `${typePart}fts${configPart}.${query}`);\r\n        return this;\r\n    }\r\n    /**\r\n     * Match only rows where each column in `query` keys is equal to its\r\n     * associated value. Shorthand for multiple `.eq()`s.\r\n     *\r\n     * @param query - The object to filter with, with column names as keys mapped\r\n     * to their filter values\r\n     */\r\n    match(query) {\r\n        Object.entries(query).forEach(([column, value]) => {\r\n            this.url.searchParams.append(column, `eq.${value}`);\r\n        });\r\n        return this;\r\n    }\r\n    /**\r\n     * Match only rows which doesn't satisfy the filter.\r\n     *\r\n     * Unlike most filters, `opearator` and `value` are used as-is and need to\r\n     * follow [PostgREST\r\n     * syntax](https://postgrest.org/en/stable/api.html#operators). You also need\r\n     * to make sure they are properly sanitized.\r\n     *\r\n     * @param column - The column to filter on\r\n     * @param operator - The operator to be negated to filter with, following\r\n     * PostgREST syntax\r\n     * @param value - The value to filter with, following PostgREST syntax\r\n     */\r\n    not(column, operator, value) {\r\n        this.url.searchParams.append(column, `not.${operator}.${value}`);\r\n        return this;\r\n    }\r\n    /**\r\n     * Match only rows which satisfy at least one of the filters.\r\n     *\r\n     * Unlike most filters, `filters` is used as-is and needs to follow [PostgREST\r\n     * syntax](https://postgrest.org/en/stable/api.html#operators). You also need\r\n     * to make sure it's properly sanitized.\r\n     *\r\n     * It's currently not possible to do an `.or()` filter across multiple tables.\r\n     *\r\n     * @param filters - The filters to use, following PostgREST syntax\r\n     * @param options - Named parameters\r\n     * @param options.referencedTable - Set this to filter on referenced tables\r\n     * instead of the parent table\r\n     * @param options.foreignTable - Deprecated, use `referencedTable` instead\r\n     */\r\n    or(filters, { foreignTable, referencedTable = foreignTable, } = {}) {\r\n        const key = referencedTable ? `${referencedTable}.or` : 'or';\r\n        this.url.searchParams.append(key, `(${filters})`);\r\n        return this;\r\n    }\r\n    /**\r\n     * Match only rows which satisfy the filter. This is an escape hatch - you\r\n     * should use the specific filter methods wherever possible.\r\n     *\r\n     * Unlike most filters, `opearator` and `value` are used as-is and need to\r\n     * follow [PostgREST\r\n     * syntax](https://postgrest.org/en/stable/api.html#operators). You also need\r\n     * to make sure they are properly sanitized.\r\n     *\r\n     * @param column - The column to filter on\r\n     * @param operator - The operator to filter with, following PostgREST syntax\r\n     * @param value - The value to filter with, following PostgREST syntax\r\n     */\r\n    filter(column, operator, value) {\r\n        this.url.searchParams.append(column, `${operator}.${value}`);\r\n        return this;\r\n    }\r\n}\r\n"],"mappings":"AAAA,OAAOA,yBAAyB,MAAM,6BAA6B;AACnE,eAAe,MAAMC,sBAAsB,SAASD,yBAAyB,CAAC;EAC1E;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACIE,EAAEA,CAACC,MAAM,EAAEC,KAAK,EAAE;IACd,IAAI,CAACC,GAAG,CAACC,YAAY,CAACC,MAAM,CAACJ,MAAM,EAAG,MAAKC,KAAM,EAAC,CAAC;IACnD,OAAO,IAAI;EACf;EACA;AACJ;AACA;AACA;AACA;AACA;EACII,GAAGA,CAACL,MAAM,EAAEC,KAAK,EAAE;IACf,IAAI,CAACC,GAAG,CAACC,YAAY,CAACC,MAAM,CAACJ,MAAM,EAAG,OAAMC,KAAM,EAAC,CAAC;IACpD,OAAO,IAAI;EACf;EACA;AACJ;AACA;AACA;AACA;AACA;EACIK,EAAEA,CAACN,MAAM,EAAEC,KAAK,EAAE;IACd,IAAI,CAACC,GAAG,CAACC,YAAY,CAACC,MAAM,CAACJ,MAAM,EAAG,MAAKC,KAAM,EAAC,CAAC;IACnD,OAAO,IAAI;EACf;EACA;AACJ;AACA;AACA;AACA;AACA;EACIM,GAAGA,CAACP,MAAM,EAAEC,KAAK,EAAE;IACf,IAAI,CAACC,GAAG,CAACC,YAAY,CAACC,MAAM,CAACJ,MAAM,EAAG,OAAMC,KAAM,EAAC,CAAC;IACpD,OAAO,IAAI;EACf;EACA;AACJ;AACA;AACA;AACA;AACA;EACIO,EAAEA,CAACR,MAAM,EAAEC,KAAK,EAAE;IACd,IAAI,CAACC,GAAG,CAACC,YAAY,CAACC,MAAM,CAACJ,MAAM,EAAG,MAAKC,KAAM,EAAC,CAAC;IACnD,OAAO,IAAI;EACf;EACA;AACJ;AACA;AACA;AACA;AACA;EACIQ,GAAGA,CAACT,MAAM,EAAEC,KAAK,EAAE;IACf,IAAI,CAACC,GAAG,CAACC,YAAY,CAACC,MAAM,CAACJ,MAAM,EAAG,OAAMC,KAAM,EAAC,CAAC;IACpD,OAAO,IAAI;EACf;EACA;AACJ;AACA;AACA;AACA;AACA;EACIS,IAAIA,CAACV,MAAM,EAAEW,OAAO,EAAE;IAClB,IAAI,CAACT,GAAG,CAACC,YAAY,CAACC,MAAM,CAACJ,MAAM,EAAG,QAAOW,OAAQ,EAAC,CAAC;IACvD,OAAO,IAAI;EACf;EACA;AACJ;AACA;AACA;AACA;AACA;EACIC,SAASA,CAACZ,MAAM,EAAEa,QAAQ,EAAE;IACxB,IAAI,CAACX,GAAG,CAACC,YAAY,CAACC,MAAM,CAACJ,MAAM,EAAG,cAAaa,QAAQ,CAACC,IAAI,CAAC,GAAG,CAAE,GAAE,CAAC;IACzE,OAAO,IAAI;EACf;EACA;AACJ;AACA;AACA;AACA;AACA;EACIC,SAASA,CAACf,MAAM,EAAEa,QAAQ,EAAE;IACxB,IAAI,CAACX,GAAG,CAACC,YAAY,CAACC,MAAM,CAACJ,MAAM,EAAG,cAAaa,QAAQ,CAACC,IAAI,CAAC,GAAG,CAAE,GAAE,CAAC;IACzE,OAAO,IAAI;EACf;EACA;AACJ;AACA;AACA;AACA;AACA;EACIE,KAAKA,CAAChB,MAAM,EAAEW,OAAO,EAAE;IACnB,IAAI,CAACT,GAAG,CAACC,YAAY,CAACC,MAAM,CAACJ,MAAM,EAAG,SAAQW,OAAQ,EAAC,CAAC;IACxD,OAAO,IAAI;EACf;EACA;AACJ;AACA;AACA;AACA;AACA;EACIM,UAAUA,CAACjB,MAAM,EAAEa,QAAQ,EAAE;IACzB,IAAI,CAACX,GAAG,CAACC,YAAY,CAACC,MAAM,CAACJ,MAAM,EAAG,eAAca,QAAQ,CAACC,IAAI,CAAC,GAAG,CAAE,GAAE,CAAC;IAC1E,OAAO,IAAI;EACf;EACA;AACJ;AACA;AACA;AACA;AACA;EACII,UAAUA,CAAClB,MAAM,EAAEa,QAAQ,EAAE;IACzB,IAAI,CAACX,GAAG,CAACC,YAAY,CAACC,MAAM,CAACJ,MAAM,EAAG,eAAca,QAAQ,CAACC,IAAI,CAAC,GAAG,CAAE,GAAE,CAAC;IAC1E,OAAO,IAAI;EACf;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIK,EAAEA,CAACnB,MAAM,EAAEC,KAAK,EAAE;IACd,IAAI,CAACC,GAAG,CAACC,YAAY,CAACC,MAAM,CAACJ,MAAM,EAAG,MAAKC,KAAM,EAAC,CAAC;IACnD,OAAO,IAAI;EACf;EACA;AACJ;AACA;AACA;AACA;AACA;EACImB,EAAEA,CAACpB,MAAM,EAAEqB,MAAM,EAAE;IACf,MAAMC,aAAa,GAAGD,MAAM,CACvBE,GAAG,CAAEC,CAAC,IAAK;MACZ;MACA;MACA,IAAI,OAAOA,CAAC,KAAK,QAAQ,IAAI,IAAIC,MAAM,CAAC,OAAO,CAAC,CAACC,IAAI,CAACF,CAAC,CAAC,EACpD,OAAQ,IAAGA,CAAE,GAAE,CAAC,KAEhB,OAAQ,GAAEA,CAAE,EAAC;IACrB,CAAC,CAAC,CACGV,IAAI,CAAC,GAAG,CAAC;IACd,IAAI,CAACZ,GAAG,CAACC,YAAY,CAACC,MAAM,CAACJ,MAAM,EAAG,OAAMsB,aAAc,GAAE,CAAC;IAC7D,OAAO,IAAI;EACf;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACIK,QAAQA,CAAC3B,MAAM,EAAEC,KAAK,EAAE;IACpB,IAAI,OAAOA,KAAK,KAAK,QAAQ,EAAE;MAC3B;MACA;MACA,IAAI,CAACC,GAAG,CAACC,YAAY,CAACC,MAAM,CAACJ,MAAM,EAAG,MAAKC,KAAM,EAAC,CAAC;IACvD,CAAC,MACI,IAAI2B,KAAK,CAACC,OAAO,CAAC5B,KAAK,CAAC,EAAE;MAC3B;MACA,IAAI,CAACC,GAAG,CAACC,YAAY,CAACC,MAAM,CAACJ,MAAM,EAAG,OAAMC,KAAK,CAACa,IAAI,CAAC,GAAG,CAAE,GAAE,CAAC;IACnE,CAAC,MACI;MACD;MACA,IAAI,CAACZ,GAAG,CAACC,YAAY,CAACC,MAAM,CAACJ,MAAM,EAAG,MAAK8B,IAAI,CAACC,SAAS,CAAC9B,KAAK,CAAE,EAAC,CAAC;IACvE;IACA,OAAO,IAAI;EACf;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACI+B,WAAWA,CAAChC,MAAM,EAAEC,KAAK,EAAE;IACvB,IAAI,OAAOA,KAAK,KAAK,QAAQ,EAAE;MAC3B;MACA,IAAI,CAACC,GAAG,CAACC,YAAY,CAACC,MAAM,CAACJ,MAAM,EAAG,MAAKC,KAAM,EAAC,CAAC;IACvD,CAAC,MACI,IAAI2B,KAAK,CAACC,OAAO,CAAC5B,KAAK,CAAC,EAAE;MAC3B;MACA,IAAI,CAACC,GAAG,CAACC,YAAY,CAACC,MAAM,CAACJ,MAAM,EAAG,OAAMC,KAAK,CAACa,IAAI,CAAC,GAAG,CAAE,GAAE,CAAC;IACnE,CAAC,MACI;MACD;MACA,IAAI,CAACZ,GAAG,CAACC,YAAY,CAACC,MAAM,CAACJ,MAAM,EAAG,MAAK8B,IAAI,CAACC,SAAS,CAAC9B,KAAK,CAAE,EAAC,CAAC;IACvE;IACA,OAAO,IAAI;EACf;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACIgC,OAAOA,CAACjC,MAAM,EAAEkC,KAAK,EAAE;IACnB,IAAI,CAAChC,GAAG,CAACC,YAAY,CAACC,MAAM,CAACJ,MAAM,EAAG,MAAKkC,KAAM,EAAC,CAAC;IACnD,OAAO,IAAI;EACf;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,QAAQA,CAACnC,MAAM,EAAEkC,KAAK,EAAE;IACpB,IAAI,CAAChC,GAAG,CAACC,YAAY,CAACC,MAAM,CAACJ,MAAM,EAAG,OAAMkC,KAAM,EAAC,CAAC;IACpD,OAAO,IAAI;EACf;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACIE,OAAOA,CAACpC,MAAM,EAAEkC,KAAK,EAAE;IACnB,IAAI,CAAChC,GAAG,CAACC,YAAY,CAACC,MAAM,CAACJ,MAAM,EAAG,MAAKkC,KAAM,EAAC,CAAC;IACnD,OAAO,IAAI;EACf;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACIG,QAAQA,CAACrC,MAAM,EAAEkC,KAAK,EAAE;IACpB,IAAI,CAAChC,GAAG,CAACC,YAAY,CAACC,MAAM,CAACJ,MAAM,EAAG,OAAMkC,KAAM,EAAC,CAAC;IACpD,OAAO,IAAI;EACf;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACII,aAAaA,CAACtC,MAAM,EAAEkC,KAAK,EAAE;IACzB,IAAI,CAAChC,GAAG,CAACC,YAAY,CAACC,MAAM,CAACJ,MAAM,EAAG,OAAMkC,KAAM,EAAC,CAAC;IACpD,OAAO,IAAI;EACf;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACIK,QAAQA,CAACvC,MAAM,EAAEC,KAAK,EAAE;IACpB,IAAI,OAAOA,KAAK,KAAK,QAAQ,EAAE;MAC3B;MACA,IAAI,CAACC,GAAG,CAACC,YAAY,CAACC,MAAM,CAACJ,MAAM,EAAG,MAAKC,KAAM,EAAC,CAAC;IACvD,CAAC,MACI;MACD;MACA,IAAI,CAACC,GAAG,CAACC,YAAY,CAACC,MAAM,CAACJ,MAAM,EAAG,OAAMC,KAAK,CAACa,IAAI,CAAC,GAAG,CAAE,GAAE,CAAC;IACnE;IACA,OAAO,IAAI;EACf;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI0B,UAAUA,CAACxC,MAAM,EAAEyC,KAAK,EAAE;IAAEC,MAAM;IAAEC;EAAK,CAAC,GAAG,CAAC,CAAC,EAAE;IAC7C,IAAIC,QAAQ,GAAG,EAAE;IACjB,IAAID,IAAI,KAAK,OAAO,EAAE;MAClBC,QAAQ,GAAG,IAAI;IACnB,CAAC,MACI,IAAID,IAAI,KAAK,QAAQ,EAAE;MACxBC,QAAQ,GAAG,IAAI;IACnB,CAAC,MACI,IAAID,IAAI,KAAK,WAAW,EAAE;MAC3BC,QAAQ,GAAG,GAAG;IAClB;IACA,MAAMC,UAAU,GAAGH,MAAM,KAAKI,SAAS,GAAG,EAAE,GAAI,IAAGJ,MAAO,GAAE;IAC5D,IAAI,CAACxC,GAAG,CAACC,YAAY,CAACC,MAAM,CAACJ,MAAM,EAAG,GAAE4C,QAAS,MAAKC,UAAW,IAAGJ,KAAM,EAAC,CAAC;IAC5E,OAAO,IAAI;EACf;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACIM,KAAKA,CAACN,KAAK,EAAE;IACTO,MAAM,CAACC,OAAO,CAACR,KAAK,CAAC,CAACS,OAAO,CAAC,CAAC,CAAClD,MAAM,EAAEC,KAAK,CAAC,KAAK;MAC/C,IAAI,CAACC,GAAG,CAACC,YAAY,CAACC,MAAM,CAACJ,MAAM,EAAG,MAAKC,KAAM,EAAC,CAAC;IACvD,CAAC,CAAC;IACF,OAAO,IAAI;EACf;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIkD,GAAGA,CAACnD,MAAM,EAAEoD,QAAQ,EAAEnD,KAAK,EAAE;IACzB,IAAI,CAACC,GAAG,CAACC,YAAY,CAACC,MAAM,CAACJ,MAAM,EAAG,OAAMoD,QAAS,IAAGnD,KAAM,EAAC,CAAC;IAChE,OAAO,IAAI;EACf;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIoD,EAAEA,CAACC,OAAO,EAAE;IAAEC,YAAY;IAAEC,eAAe,GAAGD;EAAc,CAAC,GAAG,CAAC,CAAC,EAAE;IAChE,MAAME,GAAG,GAAGD,eAAe,GAAI,GAAEA,eAAgB,KAAI,GAAG,IAAI;IAC5D,IAAI,CAACtD,GAAG,CAACC,YAAY,CAACC,MAAM,CAACqD,GAAG,EAAG,IAAGH,OAAQ,GAAE,CAAC;IACjD,OAAO,IAAI;EACf;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACII,MAAMA,CAAC1D,MAAM,EAAEoD,QAAQ,EAAEnD,KAAK,EAAE;IAC5B,IAAI,CAACC,GAAG,CAACC,YAAY,CAACC,MAAM,CAACJ,MAAM,EAAG,GAAEoD,QAAS,IAAGnD,KAAM,EAAC,CAAC;IAC5D,OAAO,IAAI;EACf;AACJ"},"metadata":{},"sourceType":"module","externalDependencies":[]}