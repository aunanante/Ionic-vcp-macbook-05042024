{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/jclon/chatgptVcp/Ionic-vcp-macbook27mars22024/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { CHANNEL_EVENTS, CHANNEL_STATES } from './lib/constants';\nimport Push from './lib/push';\nimport Timer from './lib/timer';\nimport RealtimePresence from './RealtimePresence';\nimport * as Transformers from './lib/transformers';\nexport var REALTIME_POSTGRES_CHANGES_LISTEN_EVENT;\n(function (REALTIME_POSTGRES_CHANGES_LISTEN_EVENT) {\n  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"ALL\"] = \"*\";\n  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"INSERT\"] = \"INSERT\";\n  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"UPDATE\"] = \"UPDATE\";\n  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"DELETE\"] = \"DELETE\";\n})(REALTIME_POSTGRES_CHANGES_LISTEN_EVENT || (REALTIME_POSTGRES_CHANGES_LISTEN_EVENT = {}));\nexport var REALTIME_LISTEN_TYPES;\n(function (REALTIME_LISTEN_TYPES) {\n  REALTIME_LISTEN_TYPES[\"BROADCAST\"] = \"broadcast\";\n  REALTIME_LISTEN_TYPES[\"PRESENCE\"] = \"presence\";\n  /**\r\n   * listen to Postgres changes.\r\n   */\n  REALTIME_LISTEN_TYPES[\"POSTGRES_CHANGES\"] = \"postgres_changes\";\n})(REALTIME_LISTEN_TYPES || (REALTIME_LISTEN_TYPES = {}));\nexport var REALTIME_SUBSCRIBE_STATES;\n(function (REALTIME_SUBSCRIBE_STATES) {\n  REALTIME_SUBSCRIBE_STATES[\"SUBSCRIBED\"] = \"SUBSCRIBED\";\n  REALTIME_SUBSCRIBE_STATES[\"TIMED_OUT\"] = \"TIMED_OUT\";\n  REALTIME_SUBSCRIBE_STATES[\"CLOSED\"] = \"CLOSED\";\n  REALTIME_SUBSCRIBE_STATES[\"CHANNEL_ERROR\"] = \"CHANNEL_ERROR\";\n})(REALTIME_SUBSCRIBE_STATES || (REALTIME_SUBSCRIBE_STATES = {}));\nexport const REALTIME_CHANNEL_STATES = CHANNEL_STATES;\n/** A channel is the basic building block of Realtime\r\n * and narrows the scope of data flow to subscribed clients.\r\n * You can think of a channel as a chatroom where participants are able to see who's online\r\n * and send and receive messages.\r\n */\nexport default class RealtimeChannel {\n  constructor( /** Topic name can be any string. */\n  topic, params = {\n    config: {}\n  }, socket) {\n    this.topic = topic;\n    this.params = params;\n    this.socket = socket;\n    this.bindings = {};\n    this.state = CHANNEL_STATES.closed;\n    this.joinedOnce = false;\n    this.pushBuffer = [];\n    this.subTopic = topic.replace(/^realtime:/i, '');\n    this.params.config = Object.assign({\n      broadcast: {\n        ack: false,\n        self: false\n      },\n      presence: {\n        key: ''\n      }\n    }, params.config);\n    this.timeout = this.socket.timeout;\n    this.joinPush = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout);\n    this.rejoinTimer = new Timer(() => this._rejoinUntilConnected(), this.socket.reconnectAfterMs);\n    this.joinPush.receive('ok', () => {\n      this.state = CHANNEL_STATES.joined;\n      this.rejoinTimer.reset();\n      this.pushBuffer.forEach(pushEvent => pushEvent.send());\n      this.pushBuffer = [];\n    });\n    this._onClose(() => {\n      this.rejoinTimer.reset();\n      this.socket.log('channel', `close ${this.topic} ${this._joinRef()}`);\n      this.state = CHANNEL_STATES.closed;\n      this.socket._remove(this);\n    });\n    this._onError(reason => {\n      if (this._isLeaving() || this._isClosed()) {\n        return;\n      }\n      this.socket.log('channel', `error ${this.topic}`, reason);\n      this.state = CHANNEL_STATES.errored;\n      this.rejoinTimer.scheduleTimeout();\n    });\n    this.joinPush.receive('timeout', () => {\n      if (!this._isJoining()) {\n        return;\n      }\n      this.socket.log('channel', `timeout ${this.topic}`, this.joinPush.timeout);\n      this.state = CHANNEL_STATES.errored;\n      this.rejoinTimer.scheduleTimeout();\n    });\n    this._on(CHANNEL_EVENTS.reply, {}, (payload, ref) => {\n      this._trigger(this._replyEventName(ref), payload);\n    });\n    this.presence = new RealtimePresence(this);\n    this.broadcastEndpointURL = this._broadcastEndpointURL();\n  }\n  /** Subscribe registers your client with the server */\n  subscribe(callback, timeout = this.timeout) {\n    var _a, _b;\n    if (!this.socket.isConnected()) {\n      this.socket.connect();\n    }\n    if (this.joinedOnce) {\n      throw `tried to subscribe multiple times. 'subscribe' can only be called a single time per channel instance`;\n    } else {\n      const {\n        config: {\n          broadcast,\n          presence\n        }\n      } = this.params;\n      this._onError(e => callback && callback('CHANNEL_ERROR', e));\n      this._onClose(() => callback && callback('CLOSED'));\n      const accessTokenPayload = {};\n      const config = {\n        broadcast,\n        presence,\n        postgres_changes: (_b = (_a = this.bindings.postgres_changes) === null || _a === void 0 ? void 0 : _a.map(r => r.filter)) !== null && _b !== void 0 ? _b : []\n      };\n      if (this.socket.accessToken) {\n        accessTokenPayload.access_token = this.socket.accessToken;\n      }\n      this.updateJoinPayload(Object.assign({\n        config\n      }, accessTokenPayload));\n      this.joinedOnce = true;\n      this._rejoin(timeout);\n      this.joinPush.receive('ok', ({\n        postgres_changes: serverPostgresFilters\n      }) => {\n        var _a;\n        this.socket.accessToken && this.socket.setAuth(this.socket.accessToken);\n        if (serverPostgresFilters === undefined) {\n          callback && callback('SUBSCRIBED');\n          return;\n        } else {\n          const clientPostgresBindings = this.bindings.postgres_changes;\n          const bindingsLen = (_a = clientPostgresBindings === null || clientPostgresBindings === void 0 ? void 0 : clientPostgresBindings.length) !== null && _a !== void 0 ? _a : 0;\n          const newPostgresBindings = [];\n          for (let i = 0; i < bindingsLen; i++) {\n            const clientPostgresBinding = clientPostgresBindings[i];\n            const {\n              filter: {\n                event,\n                schema,\n                table,\n                filter\n              }\n            } = clientPostgresBinding;\n            const serverPostgresFilter = serverPostgresFilters && serverPostgresFilters[i];\n            if (serverPostgresFilter && serverPostgresFilter.event === event && serverPostgresFilter.schema === schema && serverPostgresFilter.table === table && serverPostgresFilter.filter === filter) {\n              newPostgresBindings.push(Object.assign(Object.assign({}, clientPostgresBinding), {\n                id: serverPostgresFilter.id\n              }));\n            } else {\n              this.unsubscribe();\n              callback && callback('CHANNEL_ERROR', new Error('mismatch between server and client bindings for postgres changes'));\n              return;\n            }\n          }\n          this.bindings.postgres_changes = newPostgresBindings;\n          callback && callback('SUBSCRIBED');\n          return;\n        }\n      }).receive('error', error => {\n        callback && callback('CHANNEL_ERROR', new Error(JSON.stringify(Object.values(error).join(', ') || 'error')));\n        return;\n      }).receive('timeout', () => {\n        callback && callback('TIMED_OUT');\n        return;\n      });\n    }\n    return this;\n  }\n  presenceState() {\n    return this.presence.state;\n  }\n  track(payload, opts = {}) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      return yield _this.send({\n        type: 'presence',\n        event: 'track',\n        payload\n      }, opts.timeout || _this.timeout);\n    })();\n  }\n  untrack(opts = {}) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      return yield _this2.send({\n        type: 'presence',\n        event: 'untrack'\n      }, opts);\n    })();\n  }\n  on(type, filter, callback) {\n    return this._on(type, filter, callback);\n  }\n  /**\r\n   * Sends a message into the channel.\r\n   *\r\n   * @param args Arguments to send to channel\r\n   * @param args.type The type of event to send\r\n   * @param args.event The name of the event being sent\r\n   * @param args.payload Payload to be sent\r\n   * @param opts Options to be used during the send process\r\n   */\n  send(args, opts = {}) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      var _a, _b;\n      if (!_this3._canPush() && args.type === 'broadcast') {\n        const {\n          event,\n          payload: endpoint_payload\n        } = args;\n        const options = {\n          method: 'POST',\n          headers: {\n            apikey: (_a = _this3.socket.accessToken) !== null && _a !== void 0 ? _a : '',\n            'Content-Type': 'application/json'\n          },\n          body: JSON.stringify({\n            messages: [{\n              topic: _this3.subTopic,\n              event,\n              payload: endpoint_payload\n            }]\n          })\n        };\n        try {\n          const response = yield _this3._fetchWithTimeout(_this3.broadcastEndpointURL, options, (_b = opts.timeout) !== null && _b !== void 0 ? _b : _this3.timeout);\n          if (response.ok) {\n            return 'ok';\n          } else {\n            return 'error';\n          }\n        } catch (error) {\n          if (error.name === 'AbortError') {\n            return 'timed out';\n          } else {\n            return 'error';\n          }\n        }\n      } else {\n        return new Promise(resolve => {\n          var _a, _b, _c;\n          const push = _this3._push(args.type, args, opts.timeout || _this3.timeout);\n          if (args.type === 'broadcast' && !((_c = (_b = (_a = _this3.params) === null || _a === void 0 ? void 0 : _a.config) === null || _b === void 0 ? void 0 : _b.broadcast) === null || _c === void 0 ? void 0 : _c.ack)) {\n            resolve('ok');\n          }\n          push.receive('ok', () => resolve('ok'));\n          push.receive('timeout', () => resolve('timed out'));\n        });\n      }\n    })();\n  }\n  updateJoinPayload(payload) {\n    this.joinPush.updatePayload(payload);\n  }\n  /**\r\n   * Leaves the channel.\r\n   *\r\n   * Unsubscribes from server events, and instructs channel to terminate on server.\r\n   * Triggers onClose() hooks.\r\n   *\r\n   * To receive leave acknowledgements, use the a `receive` hook to bind to the server ack, ie:\r\n   * channel.unsubscribe().receive(\"ok\", () => alert(\"left!\") )\r\n   */\n  unsubscribe(timeout = this.timeout) {\n    this.state = CHANNEL_STATES.leaving;\n    const onClose = () => {\n      this.socket.log('channel', `leave ${this.topic}`);\n      this._trigger(CHANNEL_EVENTS.close, 'leave', this._joinRef());\n    };\n    this.rejoinTimer.reset();\n    // Destroy joinPush to avoid connection timeouts during unscription phase\n    this.joinPush.destroy();\n    return new Promise(resolve => {\n      const leavePush = new Push(this, CHANNEL_EVENTS.leave, {}, timeout);\n      leavePush.receive('ok', () => {\n        onClose();\n        resolve('ok');\n      }).receive('timeout', () => {\n        onClose();\n        resolve('timed out');\n      }).receive('error', () => {\n        resolve('error');\n      });\n      leavePush.send();\n      if (!this._canPush()) {\n        leavePush.trigger('ok', {});\n      }\n    });\n  }\n  /** @internal */\n  _broadcastEndpointURL() {\n    let url = this.socket.endPoint;\n    url = url.replace(/^ws/i, 'http');\n    url = url.replace(/(\\/socket\\/websocket|\\/socket|\\/websocket)\\/?$/i, '');\n    return url.replace(/\\/+$/, '') + '/api/broadcast';\n  }\n  _fetchWithTimeout(url, options, timeout) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      const controller = new AbortController();\n      const id = setTimeout(() => controller.abort(), timeout);\n      const response = yield _this4.socket.fetch(url, Object.assign(Object.assign({}, options), {\n        signal: controller.signal\n      }));\n      clearTimeout(id);\n      return response;\n    })();\n  }\n  /** @internal */\n  _push(event, payload, timeout = this.timeout) {\n    if (!this.joinedOnce) {\n      throw `tried to push '${event}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`;\n    }\n    let pushEvent = new Push(this, event, payload, timeout);\n    if (this._canPush()) {\n      pushEvent.send();\n    } else {\n      pushEvent.startTimeout();\n      this.pushBuffer.push(pushEvent);\n    }\n    return pushEvent;\n  }\n  /**\r\n   * Overridable message hook\r\n   *\r\n   * Receives all events for specialized message handling before dispatching to the channel callbacks.\r\n   * Must return the payload, modified or unmodified.\r\n   *\r\n   * @internal\r\n   */\n  _onMessage(_event, payload, _ref) {\n    return payload;\n  }\n  /** @internal */\n  _isMember(topic) {\n    return this.topic === topic;\n  }\n  /** @internal */\n  _joinRef() {\n    return this.joinPush.ref;\n  }\n  /** @internal */\n  _trigger(type, payload, ref) {\n    var _a, _b;\n    const typeLower = type.toLocaleLowerCase();\n    const {\n      close,\n      error,\n      leave,\n      join\n    } = CHANNEL_EVENTS;\n    const events = [close, error, leave, join];\n    if (ref && events.indexOf(typeLower) >= 0 && ref !== this._joinRef()) {\n      return;\n    }\n    let handledPayload = this._onMessage(typeLower, payload, ref);\n    if (payload && !handledPayload) {\n      throw 'channel onMessage callbacks must return the payload, modified or unmodified';\n    }\n    if (['insert', 'update', 'delete'].includes(typeLower)) {\n      (_a = this.bindings.postgres_changes) === null || _a === void 0 ? void 0 : _a.filter(bind => {\n        var _a, _b, _c;\n        return ((_a = bind.filter) === null || _a === void 0 ? void 0 : _a.event) === '*' || ((_c = (_b = bind.filter) === null || _b === void 0 ? void 0 : _b.event) === null || _c === void 0 ? void 0 : _c.toLocaleLowerCase()) === typeLower;\n      }).map(bind => bind.callback(handledPayload, ref));\n    } else {\n      (_b = this.bindings[typeLower]) === null || _b === void 0 ? void 0 : _b.filter(bind => {\n        var _a, _b, _c, _d, _e, _f;\n        if (['broadcast', 'presence', 'postgres_changes'].includes(typeLower)) {\n          if ('id' in bind) {\n            const bindId = bind.id;\n            const bindEvent = (_a = bind.filter) === null || _a === void 0 ? void 0 : _a.event;\n            return bindId && ((_b = payload.ids) === null || _b === void 0 ? void 0 : _b.includes(bindId)) && (bindEvent === '*' || (bindEvent === null || bindEvent === void 0 ? void 0 : bindEvent.toLocaleLowerCase()) === ((_c = payload.data) === null || _c === void 0 ? void 0 : _c.type.toLocaleLowerCase()));\n          } else {\n            const bindEvent = (_e = (_d = bind === null || bind === void 0 ? void 0 : bind.filter) === null || _d === void 0 ? void 0 : _d.event) === null || _e === void 0 ? void 0 : _e.toLocaleLowerCase();\n            return bindEvent === '*' || bindEvent === ((_f = payload === null || payload === void 0 ? void 0 : payload.event) === null || _f === void 0 ? void 0 : _f.toLocaleLowerCase());\n          }\n        } else {\n          return bind.type.toLocaleLowerCase() === typeLower;\n        }\n      }).map(bind => {\n        if (typeof handledPayload === 'object' && 'ids' in handledPayload) {\n          const postgresChanges = handledPayload.data;\n          const {\n            schema,\n            table,\n            commit_timestamp,\n            type,\n            errors\n          } = postgresChanges;\n          const enrichedPayload = {\n            schema: schema,\n            table: table,\n            commit_timestamp: commit_timestamp,\n            eventType: type,\n            new: {},\n            old: {},\n            errors: errors\n          };\n          handledPayload = Object.assign(Object.assign({}, enrichedPayload), this._getPayloadRecords(postgresChanges));\n        }\n        bind.callback(handledPayload, ref);\n      });\n    }\n  }\n  /** @internal */\n  _isClosed() {\n    return this.state === CHANNEL_STATES.closed;\n  }\n  /** @internal */\n  _isJoined() {\n    return this.state === CHANNEL_STATES.joined;\n  }\n  /** @internal */\n  _isJoining() {\n    return this.state === CHANNEL_STATES.joining;\n  }\n  /** @internal */\n  _isLeaving() {\n    return this.state === CHANNEL_STATES.leaving;\n  }\n  /** @internal */\n  _replyEventName(ref) {\n    return `chan_reply_${ref}`;\n  }\n  /** @internal */\n  _on(type, filter, callback) {\n    const typeLower = type.toLocaleLowerCase();\n    const binding = {\n      type: typeLower,\n      filter: filter,\n      callback: callback\n    };\n    if (this.bindings[typeLower]) {\n      this.bindings[typeLower].push(binding);\n    } else {\n      this.bindings[typeLower] = [binding];\n    }\n    return this;\n  }\n  /** @internal */\n  _off(type, filter) {\n    const typeLower = type.toLocaleLowerCase();\n    this.bindings[typeLower] = this.bindings[typeLower].filter(bind => {\n      var _a;\n      return !(((_a = bind.type) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) === typeLower && RealtimeChannel.isEqual(bind.filter, filter));\n    });\n    return this;\n  }\n  /** @internal */\n  static isEqual(obj1, obj2) {\n    if (Object.keys(obj1).length !== Object.keys(obj2).length) {\n      return false;\n    }\n    for (const k in obj1) {\n      if (obj1[k] !== obj2[k]) {\n        return false;\n      }\n    }\n    return true;\n  }\n  /** @internal */\n  _rejoinUntilConnected() {\n    this.rejoinTimer.scheduleTimeout();\n    if (this.socket.isConnected()) {\n      this._rejoin();\n    }\n  }\n  /**\r\n   * Registers a callback that will be executed when the channel closes.\r\n   *\r\n   * @internal\r\n   */\n  _onClose(callback) {\n    this._on(CHANNEL_EVENTS.close, {}, callback);\n  }\n  /**\r\n   * Registers a callback that will be executed when the channel encounteres an error.\r\n   *\r\n   * @internal\r\n   */\n  _onError(callback) {\n    this._on(CHANNEL_EVENTS.error, {}, reason => callback(reason));\n  }\n  /**\r\n   * Returns `true` if the socket is connected and the channel has been joined.\r\n   *\r\n   * @internal\r\n   */\n  _canPush() {\n    return this.socket.isConnected() && this._isJoined();\n  }\n  /** @internal */\n  _rejoin(timeout = this.timeout) {\n    if (this._isLeaving()) {\n      return;\n    }\n    this.socket._leaveOpenTopic(this.topic);\n    this.state = CHANNEL_STATES.joining;\n    this.joinPush.resend(timeout);\n  }\n  /** @internal */\n  _getPayloadRecords(payload) {\n    const records = {\n      new: {},\n      old: {}\n    };\n    if (payload.type === 'INSERT' || payload.type === 'UPDATE') {\n      records.new = Transformers.convertChangeData(payload.columns, payload.record);\n    }\n    if (payload.type === 'UPDATE' || payload.type === 'DELETE') {\n      records.old = Transformers.convertChangeData(payload.columns, payload.old_record);\n    }\n    return records;\n  }\n}","map":{"version":3,"names":["CHANNEL_EVENTS","CHANNEL_STATES","Push","Timer","RealtimePresence","Transformers","REALTIME_POSTGRES_CHANGES_LISTEN_EVENT","REALTIME_LISTEN_TYPES","REALTIME_SUBSCRIBE_STATES","REALTIME_CHANNEL_STATES","RealtimeChannel","constructor","topic","params","config","socket","bindings","state","closed","joinedOnce","pushBuffer","subTopic","replace","Object","assign","broadcast","ack","self","presence","key","timeout","joinPush","join","rejoinTimer","_rejoinUntilConnected","reconnectAfterMs","receive","joined","reset","forEach","pushEvent","send","_onClose","log","_joinRef","_remove","_onError","reason","_isLeaving","_isClosed","errored","scheduleTimeout","_isJoining","_on","reply","payload","ref","_trigger","_replyEventName","broadcastEndpointURL","_broadcastEndpointURL","subscribe","callback","_a","_b","isConnected","connect","e","accessTokenPayload","postgres_changes","map","r","filter","accessToken","access_token","updateJoinPayload","_rejoin","serverPostgresFilters","setAuth","undefined","clientPostgresBindings","bindingsLen","length","newPostgresBindings","i","clientPostgresBinding","event","schema","table","serverPostgresFilter","push","id","unsubscribe","Error","error","JSON","stringify","values","presenceState","track","opts","_this","_asyncToGenerator","type","untrack","_this2","on","args","_this3","_canPush","endpoint_payload","options","method","headers","apikey","body","messages","response","_fetchWithTimeout","ok","name","Promise","resolve","_c","_push","updatePayload","leaving","onClose","close","destroy","leavePush","leave","trigger","url","endPoint","_this4","controller","AbortController","setTimeout","abort","fetch","signal","clearTimeout","startTimeout","_onMessage","_event","_ref","_isMember","typeLower","toLocaleLowerCase","events","indexOf","handledPayload","includes","bind","_d","_e","_f","bindId","bindEvent","ids","data","postgresChanges","commit_timestamp","errors","enrichedPayload","eventType","new","old","_getPayloadRecords","_isJoined","joining","binding","_off","isEqual","obj1","obj2","keys","k","_leaveOpenTopic","resend","records","convertChangeData","columns","record","old_record"],"sources":["C:/Users/jclon/chatgptVcp/Ionic-vcp-macbook27mars22024/node_modules/@supabase/realtime-js/dist/module/RealtimeChannel.js"],"sourcesContent":["import { CHANNEL_EVENTS, CHANNEL_STATES } from './lib/constants';\r\nimport Push from './lib/push';\r\nimport Timer from './lib/timer';\r\nimport RealtimePresence from './RealtimePresence';\r\nimport * as Transformers from './lib/transformers';\r\nexport var REALTIME_POSTGRES_CHANGES_LISTEN_EVENT;\r\n(function (REALTIME_POSTGRES_CHANGES_LISTEN_EVENT) {\r\n    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"ALL\"] = \"*\";\r\n    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"INSERT\"] = \"INSERT\";\r\n    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"UPDATE\"] = \"UPDATE\";\r\n    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"DELETE\"] = \"DELETE\";\r\n})(REALTIME_POSTGRES_CHANGES_LISTEN_EVENT || (REALTIME_POSTGRES_CHANGES_LISTEN_EVENT = {}));\r\nexport var REALTIME_LISTEN_TYPES;\r\n(function (REALTIME_LISTEN_TYPES) {\r\n    REALTIME_LISTEN_TYPES[\"BROADCAST\"] = \"broadcast\";\r\n    REALTIME_LISTEN_TYPES[\"PRESENCE\"] = \"presence\";\r\n    /**\r\n     * listen to Postgres changes.\r\n     */\r\n    REALTIME_LISTEN_TYPES[\"POSTGRES_CHANGES\"] = \"postgres_changes\";\r\n})(REALTIME_LISTEN_TYPES || (REALTIME_LISTEN_TYPES = {}));\r\nexport var REALTIME_SUBSCRIBE_STATES;\r\n(function (REALTIME_SUBSCRIBE_STATES) {\r\n    REALTIME_SUBSCRIBE_STATES[\"SUBSCRIBED\"] = \"SUBSCRIBED\";\r\n    REALTIME_SUBSCRIBE_STATES[\"TIMED_OUT\"] = \"TIMED_OUT\";\r\n    REALTIME_SUBSCRIBE_STATES[\"CLOSED\"] = \"CLOSED\";\r\n    REALTIME_SUBSCRIBE_STATES[\"CHANNEL_ERROR\"] = \"CHANNEL_ERROR\";\r\n})(REALTIME_SUBSCRIBE_STATES || (REALTIME_SUBSCRIBE_STATES = {}));\r\nexport const REALTIME_CHANNEL_STATES = CHANNEL_STATES;\r\n/** A channel is the basic building block of Realtime\r\n * and narrows the scope of data flow to subscribed clients.\r\n * You can think of a channel as a chatroom where participants are able to see who's online\r\n * and send and receive messages.\r\n */\r\nexport default class RealtimeChannel {\r\n    constructor(\r\n    /** Topic name can be any string. */\r\n    topic, params = { config: {} }, socket) {\r\n        this.topic = topic;\r\n        this.params = params;\r\n        this.socket = socket;\r\n        this.bindings = {};\r\n        this.state = CHANNEL_STATES.closed;\r\n        this.joinedOnce = false;\r\n        this.pushBuffer = [];\r\n        this.subTopic = topic.replace(/^realtime:/i, '');\r\n        this.params.config = Object.assign({\r\n            broadcast: { ack: false, self: false },\r\n            presence: { key: '' },\r\n        }, params.config);\r\n        this.timeout = this.socket.timeout;\r\n        this.joinPush = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout);\r\n        this.rejoinTimer = new Timer(() => this._rejoinUntilConnected(), this.socket.reconnectAfterMs);\r\n        this.joinPush.receive('ok', () => {\r\n            this.state = CHANNEL_STATES.joined;\r\n            this.rejoinTimer.reset();\r\n            this.pushBuffer.forEach((pushEvent) => pushEvent.send());\r\n            this.pushBuffer = [];\r\n        });\r\n        this._onClose(() => {\r\n            this.rejoinTimer.reset();\r\n            this.socket.log('channel', `close ${this.topic} ${this._joinRef()}`);\r\n            this.state = CHANNEL_STATES.closed;\r\n            this.socket._remove(this);\r\n        });\r\n        this._onError((reason) => {\r\n            if (this._isLeaving() || this._isClosed()) {\r\n                return;\r\n            }\r\n            this.socket.log('channel', `error ${this.topic}`, reason);\r\n            this.state = CHANNEL_STATES.errored;\r\n            this.rejoinTimer.scheduleTimeout();\r\n        });\r\n        this.joinPush.receive('timeout', () => {\r\n            if (!this._isJoining()) {\r\n                return;\r\n            }\r\n            this.socket.log('channel', `timeout ${this.topic}`, this.joinPush.timeout);\r\n            this.state = CHANNEL_STATES.errored;\r\n            this.rejoinTimer.scheduleTimeout();\r\n        });\r\n        this._on(CHANNEL_EVENTS.reply, {}, (payload, ref) => {\r\n            this._trigger(this._replyEventName(ref), payload);\r\n        });\r\n        this.presence = new RealtimePresence(this);\r\n        this.broadcastEndpointURL = this._broadcastEndpointURL();\r\n    }\r\n    /** Subscribe registers your client with the server */\r\n    subscribe(callback, timeout = this.timeout) {\r\n        var _a, _b;\r\n        if (!this.socket.isConnected()) {\r\n            this.socket.connect();\r\n        }\r\n        if (this.joinedOnce) {\r\n            throw `tried to subscribe multiple times. 'subscribe' can only be called a single time per channel instance`;\r\n        }\r\n        else {\r\n            const { config: { broadcast, presence }, } = this.params;\r\n            this._onError((e) => callback && callback('CHANNEL_ERROR', e));\r\n            this._onClose(() => callback && callback('CLOSED'));\r\n            const accessTokenPayload = {};\r\n            const config = {\r\n                broadcast,\r\n                presence,\r\n                postgres_changes: (_b = (_a = this.bindings.postgres_changes) === null || _a === void 0 ? void 0 : _a.map((r) => r.filter)) !== null && _b !== void 0 ? _b : [],\r\n            };\r\n            if (this.socket.accessToken) {\r\n                accessTokenPayload.access_token = this.socket.accessToken;\r\n            }\r\n            this.updateJoinPayload(Object.assign({ config }, accessTokenPayload));\r\n            this.joinedOnce = true;\r\n            this._rejoin(timeout);\r\n            this.joinPush\r\n                .receive('ok', ({ postgres_changes: serverPostgresFilters, }) => {\r\n                var _a;\r\n                this.socket.accessToken &&\r\n                    this.socket.setAuth(this.socket.accessToken);\r\n                if (serverPostgresFilters === undefined) {\r\n                    callback && callback('SUBSCRIBED');\r\n                    return;\r\n                }\r\n                else {\r\n                    const clientPostgresBindings = this.bindings.postgres_changes;\r\n                    const bindingsLen = (_a = clientPostgresBindings === null || clientPostgresBindings === void 0 ? void 0 : clientPostgresBindings.length) !== null && _a !== void 0 ? _a : 0;\r\n                    const newPostgresBindings = [];\r\n                    for (let i = 0; i < bindingsLen; i++) {\r\n                        const clientPostgresBinding = clientPostgresBindings[i];\r\n                        const { filter: { event, schema, table, filter }, } = clientPostgresBinding;\r\n                        const serverPostgresFilter = serverPostgresFilters && serverPostgresFilters[i];\r\n                        if (serverPostgresFilter &&\r\n                            serverPostgresFilter.event === event &&\r\n                            serverPostgresFilter.schema === schema &&\r\n                            serverPostgresFilter.table === table &&\r\n                            serverPostgresFilter.filter === filter) {\r\n                            newPostgresBindings.push(Object.assign(Object.assign({}, clientPostgresBinding), { id: serverPostgresFilter.id }));\r\n                        }\r\n                        else {\r\n                            this.unsubscribe();\r\n                            callback &&\r\n                                callback('CHANNEL_ERROR', new Error('mismatch between server and client bindings for postgres changes'));\r\n                            return;\r\n                        }\r\n                    }\r\n                    this.bindings.postgres_changes = newPostgresBindings;\r\n                    callback && callback('SUBSCRIBED');\r\n                    return;\r\n                }\r\n            })\r\n                .receive('error', (error) => {\r\n                callback &&\r\n                    callback('CHANNEL_ERROR', new Error(JSON.stringify(Object.values(error).join(', ') || 'error')));\r\n                return;\r\n            })\r\n                .receive('timeout', () => {\r\n                callback && callback('TIMED_OUT');\r\n                return;\r\n            });\r\n        }\r\n        return this;\r\n    }\r\n    presenceState() {\r\n        return this.presence.state;\r\n    }\r\n    async track(payload, opts = {}) {\r\n        return await this.send({\r\n            type: 'presence',\r\n            event: 'track',\r\n            payload,\r\n        }, opts.timeout || this.timeout);\r\n    }\r\n    async untrack(opts = {}) {\r\n        return await this.send({\r\n            type: 'presence',\r\n            event: 'untrack',\r\n        }, opts);\r\n    }\r\n    on(type, filter, callback) {\r\n        return this._on(type, filter, callback);\r\n    }\r\n    /**\r\n     * Sends a message into the channel.\r\n     *\r\n     * @param args Arguments to send to channel\r\n     * @param args.type The type of event to send\r\n     * @param args.event The name of the event being sent\r\n     * @param args.payload Payload to be sent\r\n     * @param opts Options to be used during the send process\r\n     */\r\n    async send(args, opts = {}) {\r\n        var _a, _b;\r\n        if (!this._canPush() && args.type === 'broadcast') {\r\n            const { event, payload: endpoint_payload } = args;\r\n            const options = {\r\n                method: 'POST',\r\n                headers: {\r\n                    apikey: (_a = this.socket.accessToken) !== null && _a !== void 0 ? _a : '',\r\n                    'Content-Type': 'application/json',\r\n                },\r\n                body: JSON.stringify({\r\n                    messages: [\r\n                        { topic: this.subTopic, event, payload: endpoint_payload },\r\n                    ],\r\n                }),\r\n            };\r\n            try {\r\n                const response = await this._fetchWithTimeout(this.broadcastEndpointURL, options, (_b = opts.timeout) !== null && _b !== void 0 ? _b : this.timeout);\r\n                if (response.ok) {\r\n                    return 'ok';\r\n                }\r\n                else {\r\n                    return 'error';\r\n                }\r\n            }\r\n            catch (error) {\r\n                if (error.name === 'AbortError') {\r\n                    return 'timed out';\r\n                }\r\n                else {\r\n                    return 'error';\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            return new Promise((resolve) => {\r\n                var _a, _b, _c;\r\n                const push = this._push(args.type, args, opts.timeout || this.timeout);\r\n                if (args.type === 'broadcast' && !((_c = (_b = (_a = this.params) === null || _a === void 0 ? void 0 : _a.config) === null || _b === void 0 ? void 0 : _b.broadcast) === null || _c === void 0 ? void 0 : _c.ack)) {\r\n                    resolve('ok');\r\n                }\r\n                push.receive('ok', () => resolve('ok'));\r\n                push.receive('timeout', () => resolve('timed out'));\r\n            });\r\n        }\r\n    }\r\n    updateJoinPayload(payload) {\r\n        this.joinPush.updatePayload(payload);\r\n    }\r\n    /**\r\n     * Leaves the channel.\r\n     *\r\n     * Unsubscribes from server events, and instructs channel to terminate on server.\r\n     * Triggers onClose() hooks.\r\n     *\r\n     * To receive leave acknowledgements, use the a `receive` hook to bind to the server ack, ie:\r\n     * channel.unsubscribe().receive(\"ok\", () => alert(\"left!\") )\r\n     */\r\n    unsubscribe(timeout = this.timeout) {\r\n        this.state = CHANNEL_STATES.leaving;\r\n        const onClose = () => {\r\n            this.socket.log('channel', `leave ${this.topic}`);\r\n            this._trigger(CHANNEL_EVENTS.close, 'leave', this._joinRef());\r\n        };\r\n        this.rejoinTimer.reset();\r\n        // Destroy joinPush to avoid connection timeouts during unscription phase\r\n        this.joinPush.destroy();\r\n        return new Promise((resolve) => {\r\n            const leavePush = new Push(this, CHANNEL_EVENTS.leave, {}, timeout);\r\n            leavePush\r\n                .receive('ok', () => {\r\n                onClose();\r\n                resolve('ok');\r\n            })\r\n                .receive('timeout', () => {\r\n                onClose();\r\n                resolve('timed out');\r\n            })\r\n                .receive('error', () => {\r\n                resolve('error');\r\n            });\r\n            leavePush.send();\r\n            if (!this._canPush()) {\r\n                leavePush.trigger('ok', {});\r\n            }\r\n        });\r\n    }\r\n    /** @internal */\r\n    _broadcastEndpointURL() {\r\n        let url = this.socket.endPoint;\r\n        url = url.replace(/^ws/i, 'http');\r\n        url = url.replace(/(\\/socket\\/websocket|\\/socket|\\/websocket)\\/?$/i, '');\r\n        return url.replace(/\\/+$/, '') + '/api/broadcast';\r\n    }\r\n    async _fetchWithTimeout(url, options, timeout) {\r\n        const controller = new AbortController();\r\n        const id = setTimeout(() => controller.abort(), timeout);\r\n        const response = await this.socket.fetch(url, Object.assign(Object.assign({}, options), { signal: controller.signal }));\r\n        clearTimeout(id);\r\n        return response;\r\n    }\r\n    /** @internal */\r\n    _push(event, payload, timeout = this.timeout) {\r\n        if (!this.joinedOnce) {\r\n            throw `tried to push '${event}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`;\r\n        }\r\n        let pushEvent = new Push(this, event, payload, timeout);\r\n        if (this._canPush()) {\r\n            pushEvent.send();\r\n        }\r\n        else {\r\n            pushEvent.startTimeout();\r\n            this.pushBuffer.push(pushEvent);\r\n        }\r\n        return pushEvent;\r\n    }\r\n    /**\r\n     * Overridable message hook\r\n     *\r\n     * Receives all events for specialized message handling before dispatching to the channel callbacks.\r\n     * Must return the payload, modified or unmodified.\r\n     *\r\n     * @internal\r\n     */\r\n    _onMessage(_event, payload, _ref) {\r\n        return payload;\r\n    }\r\n    /** @internal */\r\n    _isMember(topic) {\r\n        return this.topic === topic;\r\n    }\r\n    /** @internal */\r\n    _joinRef() {\r\n        return this.joinPush.ref;\r\n    }\r\n    /** @internal */\r\n    _trigger(type, payload, ref) {\r\n        var _a, _b;\r\n        const typeLower = type.toLocaleLowerCase();\r\n        const { close, error, leave, join } = CHANNEL_EVENTS;\r\n        const events = [close, error, leave, join];\r\n        if (ref && events.indexOf(typeLower) >= 0 && ref !== this._joinRef()) {\r\n            return;\r\n        }\r\n        let handledPayload = this._onMessage(typeLower, payload, ref);\r\n        if (payload && !handledPayload) {\r\n            throw 'channel onMessage callbacks must return the payload, modified or unmodified';\r\n        }\r\n        if (['insert', 'update', 'delete'].includes(typeLower)) {\r\n            (_a = this.bindings.postgres_changes) === null || _a === void 0 ? void 0 : _a.filter((bind) => {\r\n                var _a, _b, _c;\r\n                return (((_a = bind.filter) === null || _a === void 0 ? void 0 : _a.event) === '*' ||\r\n                    ((_c = (_b = bind.filter) === null || _b === void 0 ? void 0 : _b.event) === null || _c === void 0 ? void 0 : _c.toLocaleLowerCase()) === typeLower);\r\n            }).map((bind) => bind.callback(handledPayload, ref));\r\n        }\r\n        else {\r\n            (_b = this.bindings[typeLower]) === null || _b === void 0 ? void 0 : _b.filter((bind) => {\r\n                var _a, _b, _c, _d, _e, _f;\r\n                if (['broadcast', 'presence', 'postgres_changes'].includes(typeLower)) {\r\n                    if ('id' in bind) {\r\n                        const bindId = bind.id;\r\n                        const bindEvent = (_a = bind.filter) === null || _a === void 0 ? void 0 : _a.event;\r\n                        return (bindId &&\r\n                            ((_b = payload.ids) === null || _b === void 0 ? void 0 : _b.includes(bindId)) &&\r\n                            (bindEvent === '*' ||\r\n                                (bindEvent === null || bindEvent === void 0 ? void 0 : bindEvent.toLocaleLowerCase()) ===\r\n                                    ((_c = payload.data) === null || _c === void 0 ? void 0 : _c.type.toLocaleLowerCase())));\r\n                    }\r\n                    else {\r\n                        const bindEvent = (_e = (_d = bind === null || bind === void 0 ? void 0 : bind.filter) === null || _d === void 0 ? void 0 : _d.event) === null || _e === void 0 ? void 0 : _e.toLocaleLowerCase();\r\n                        return (bindEvent === '*' ||\r\n                            bindEvent === ((_f = payload === null || payload === void 0 ? void 0 : payload.event) === null || _f === void 0 ? void 0 : _f.toLocaleLowerCase()));\r\n                    }\r\n                }\r\n                else {\r\n                    return bind.type.toLocaleLowerCase() === typeLower;\r\n                }\r\n            }).map((bind) => {\r\n                if (typeof handledPayload === 'object' && 'ids' in handledPayload) {\r\n                    const postgresChanges = handledPayload.data;\r\n                    const { schema, table, commit_timestamp, type, errors } = postgresChanges;\r\n                    const enrichedPayload = {\r\n                        schema: schema,\r\n                        table: table,\r\n                        commit_timestamp: commit_timestamp,\r\n                        eventType: type,\r\n                        new: {},\r\n                        old: {},\r\n                        errors: errors,\r\n                    };\r\n                    handledPayload = Object.assign(Object.assign({}, enrichedPayload), this._getPayloadRecords(postgresChanges));\r\n                }\r\n                bind.callback(handledPayload, ref);\r\n            });\r\n        }\r\n    }\r\n    /** @internal */\r\n    _isClosed() {\r\n        return this.state === CHANNEL_STATES.closed;\r\n    }\r\n    /** @internal */\r\n    _isJoined() {\r\n        return this.state === CHANNEL_STATES.joined;\r\n    }\r\n    /** @internal */\r\n    _isJoining() {\r\n        return this.state === CHANNEL_STATES.joining;\r\n    }\r\n    /** @internal */\r\n    _isLeaving() {\r\n        return this.state === CHANNEL_STATES.leaving;\r\n    }\r\n    /** @internal */\r\n    _replyEventName(ref) {\r\n        return `chan_reply_${ref}`;\r\n    }\r\n    /** @internal */\r\n    _on(type, filter, callback) {\r\n        const typeLower = type.toLocaleLowerCase();\r\n        const binding = {\r\n            type: typeLower,\r\n            filter: filter,\r\n            callback: callback,\r\n        };\r\n        if (this.bindings[typeLower]) {\r\n            this.bindings[typeLower].push(binding);\r\n        }\r\n        else {\r\n            this.bindings[typeLower] = [binding];\r\n        }\r\n        return this;\r\n    }\r\n    /** @internal */\r\n    _off(type, filter) {\r\n        const typeLower = type.toLocaleLowerCase();\r\n        this.bindings[typeLower] = this.bindings[typeLower].filter((bind) => {\r\n            var _a;\r\n            return !(((_a = bind.type) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) === typeLower &&\r\n                RealtimeChannel.isEqual(bind.filter, filter));\r\n        });\r\n        return this;\r\n    }\r\n    /** @internal */\r\n    static isEqual(obj1, obj2) {\r\n        if (Object.keys(obj1).length !== Object.keys(obj2).length) {\r\n            return false;\r\n        }\r\n        for (const k in obj1) {\r\n            if (obj1[k] !== obj2[k]) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    /** @internal */\r\n    _rejoinUntilConnected() {\r\n        this.rejoinTimer.scheduleTimeout();\r\n        if (this.socket.isConnected()) {\r\n            this._rejoin();\r\n        }\r\n    }\r\n    /**\r\n     * Registers a callback that will be executed when the channel closes.\r\n     *\r\n     * @internal\r\n     */\r\n    _onClose(callback) {\r\n        this._on(CHANNEL_EVENTS.close, {}, callback);\r\n    }\r\n    /**\r\n     * Registers a callback that will be executed when the channel encounteres an error.\r\n     *\r\n     * @internal\r\n     */\r\n    _onError(callback) {\r\n        this._on(CHANNEL_EVENTS.error, {}, (reason) => callback(reason));\r\n    }\r\n    /**\r\n     * Returns `true` if the socket is connected and the channel has been joined.\r\n     *\r\n     * @internal\r\n     */\r\n    _canPush() {\r\n        return this.socket.isConnected() && this._isJoined();\r\n    }\r\n    /** @internal */\r\n    _rejoin(timeout = this.timeout) {\r\n        if (this._isLeaving()) {\r\n            return;\r\n        }\r\n        this.socket._leaveOpenTopic(this.topic);\r\n        this.state = CHANNEL_STATES.joining;\r\n        this.joinPush.resend(timeout);\r\n    }\r\n    /** @internal */\r\n    _getPayloadRecords(payload) {\r\n        const records = {\r\n            new: {},\r\n            old: {},\r\n        };\r\n        if (payload.type === 'INSERT' || payload.type === 'UPDATE') {\r\n            records.new = Transformers.convertChangeData(payload.columns, payload.record);\r\n        }\r\n        if (payload.type === 'UPDATE' || payload.type === 'DELETE') {\r\n            records.old = Transformers.convertChangeData(payload.columns, payload.old_record);\r\n        }\r\n        return records;\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}